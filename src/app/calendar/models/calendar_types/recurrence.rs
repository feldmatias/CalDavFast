/*
The RRULE attribute is used to specify a recurrence rule for a recurring event in iCalendar. The value of the RRULE attribute is a string that consists of a set of name-value pairs, where the name indicates a parameter of the recurrence rule, and the value provides the specific value for that parameter.

Here are the possible parameters that can be used in an RRULE, along with their possible values:

FREQ: The FREQ rule part identifies the type of recurrence rule.  This
      rule part MUST be specified in the recurrence rule.  Valid values
      include SECONDLY, to specify repeating events based on an interval
      of a second or more; MINUTELY, to specify repeating events based
      on an interval of a minute or more; HOURLY, to specify repeating
      events based on an interval of an hour or more; DAILY, to specify
      repeating events based on an interval of a day or more; WEEKLY, to
      specify repeating events based on an interval of a week or more;
      MONTHLY, to specify repeating events based on an interval of a
      month or more; and YEARLY, to specify repeating events based on an
      interval of a year or more.

INTERVAL: The INTERVAL rule part contains a positive integer representing at
      which intervals the recurrence rule repeats.  The default value is
      "1", meaning every second for a SECONDLY rule, every minute for a
      MINUTELY rule, every hour for an HOURLY rule, every day for a
      DAILY rule, every week for a WEEKLY rule, every month for a
      MONTHLY rule, and every year for a YEARLY rule.  For example,
      within a DAILY rule, a value of "8" means every eight days.

COUNT: Specifies the number of times the event should recur. If this parameter is not specified, the event will recur indefinitely.

UNTIL: Specifies the date and time at which the event should stop recurring. This value should be a date-time value in UTC format.

The BYSECOND rule part specifies a COMMA-separated list of seconds
within a minute.  Valid values are 0 to 60.  The BYMINUTE rule
part specifies a COMMA-separated list of minutes within an hour.
Valid values are 0 to 59.  The BYHOUR rule part specifies a COMMA-
separated list of hours of the day.  Valid values are 0 to 23.
The BYSECOND, BYMINUTE and BYHOUR rule parts MUST NOT be specified
when the associated "DTSTART" property has a DATE value type.
These rule parts MUST be ignored in RECUR value that violate the
above requirement (e.g., generated by applications that pre-date
this revision of iCalendar).

BYDAY: The BYDAY rule part specifies a COMMA-separated list of days of
      the week; SU indicates Sunday; MO indicates Monday; TU indicates
      Tuesday; WE indicates Wednesday; TH indicates Thursday; FR
      indicates Friday; and SA indicates Saturday.
      Each BYDAY value can also be preceded by a positive (+n) or
      negative (-n) integer.  If present, this indicates the nth
      occurrence of a specific day within the MONTHLY or YEARLY "RRULE".

      For example, within a MONTHLY rule, +1MO (or simply 1MO)
      represents the first Monday within the month, whereas -1MO
      represents the last Monday of the month.  The numeric value in a
      BYDAY rule part with the FREQ rule part set to YEARLY corresponds
      to an offset within the month when the BYMONTH rule part is
      present, and corresponds to an offset within the year when the
      BYWEEKNO or BYMONTH rule parts are present.  If an integer
      modifier is not present, it means all days of this type within the
      specified frequency.  For example, within a MONTHLY rule, MO
      represents all Mondays within the month.  The BYDAY rule part MUST
      NOT be specified with a numeric value when the FREQ rule part is
      not set to MONTHLY or YEARLY.  Furthermore, the BYDAY rule part
      MUST NOT be specified with a numeric value with the FREQ rule part
      set to YEARLY when the BYWEEKNO rule part is specified.

BYMONTHDAY: The BYMONTHDAY rule part specifies a COMMA-separated list of days
      of the month.  Valid values are 1 to 31 or -31 to -1.  For
      example, -10 represents the tenth to the last day of the month.
      The BYMONTHDAY rule part MUST NOT be specified when the FREQ rule
      part is set to WEEKLY.

BYYEARDAY:  The BYYEARDAY rule part specifies a COMMA-separated list of days
      of the year.  Valid values are 1 to 366 or -366 to -1.  For
      example, -1 represents the last day of the year (December 31st)
      and -306 represents the 306th to the last day of the year (March
      1st).  The BYYEARDAY rule part MUST NOT be specified when the FREQ
      rule part is set to DAILY, WEEKLY, or MONTHLY.

BYMONTH: The BYMONTH rule part specifies a COMMA-separated list of months
      of the year.  Valid values are 1 to 12.

BYWEEKNO: The BYWEEKNO rule part specifies a COMMA-separated list of
      ordinals specifying weeks of the year.  Valid values are 1 to 53
      or -53 to -1.  This corresponds to weeks according to week
      numbering as defined in [ISO.8601.2004].  A week is defined as a
      seven day period, starting on the day of the week defined to be
      the week start (see WKST).  Week number one of the calendar year
      is the first week that contains at least four (4) days in that
      calendar year.  This rule part MUST NOT be used when the FREQ rule
      part is set to anything other than YEARLY.  For example, 3
      represents the third week of the year.

         Note: Assuming a Monday week start, week 53 can only occur when
         Thursday is January 1 or if it is a leap year and Wednesday is
         January 1.

BYxxx rule parts modify the recurrence in some manner.  BYxxx rule
      parts for a period of time that is the same or greater than the
      frequency generally reduce or limit the number of occurrences of
      the recurrence generated.  For example, "FREQ=DAILY;BYMONTH=1"
      reduces the number of recurrence instances from all days (if
      BYMONTH rule part is not present) to all days in January.  BYxxx
      rule parts for a period of time less than the frequency generally
      increase or expand the number of occurrences of the recurrence.
      For example, "FREQ=YEARLY;BYMONTH=1,2" increases the number of
      days within the yearly recurrence set from 1 (if BYMONTH rule part
      is not present) to 2.

If multiple BYxxx rule parts are specified, then after evaluating
      the specified FREQ and INTERVAL rule parts, the BYxxx rule parts
      are applied to the current set of evaluated occurrences in the
      following order: BYMONTH, BYWEEKNO, BYYEARDAY, BYMONTHDAY, BYDAY,
      BYHOUR, BYMINUTE, BYSECOND and BYSETPOS; then COUNT and UNTIL are
      evaluated.

https://github.com/dateutil/dateutil/blob/master/src/dateutil/rrule.py

+----------+--------+--------+-------+-------+------+-------+------+
   |          |SECONDLY|MINUTELY|HOURLY |DAILY  |WEEKLY|MONTHLY|YEARLY|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYMONTH   |Limit   |Limit   |Limit  |Limit  |Limit |Limit  |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYWEEKNO  |N/A     |N/A     |N/A    |N/A    |N/A   |N/A    |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYYEARDAY |Limit   |Limit   |Limit  |N/A    |N/A   |N/A    |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYMONTHDAY|Limit   |Limit   |Limit  |Limit  |N/A   |Expand |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYDAY     |Limit   |Limit   |Limit  |Limit  |Expand|Note 1 |Note 2|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYHOUR    |Limit   |Limit   |Limit  |Expand |Expand|Expand |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYMINUTE  |Limit   |Limit   |Expand |Expand |Expand|Expand |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYSECOND  |Limit   |Expand  |Expand |Expand |Expand|Expand |Expand|
   +----------+--------+--------+-------+-------+------+-------+------+
   |BYSETPOS  |Limit   |Limit   |Limit  |Limit  |Limit |Limit  |Limit |
   +----------+--------+--------+-------+-------+------+-------+------+

      Note 1:  Limit if BYMONTHDAY is present; otherwise, special expand
               for MONTHLY.

      Note 2:  Limit if BYYEARDAY or BYMONTHDAY is present; otherwise,
               special expand for WEEKLY if BYWEEKNO present; otherwise,
               special expand for MONTHLY if BYMONTH present; otherwise,
               special expand for YEARLY.
*/

use chrono::{DateTime, Datelike, Timelike, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct RecurrenceVec<T: PartialEq + Clone> {
    pub data: Vec<T>,
}

impl<T: PartialEq + Clone> RecurrenceVec<T> {
    pub fn set_default(&self, items: Vec<T>) -> RecurrenceVec<T> {
        RecurrenceVec {
            data: if self.data.is_empty() {
                items
            } else {
                self.data.clone()
            },
        }
    }

    pub fn contains(&self, item: &T) -> bool {
        self.data.iter().any(|x| *x == *item)
    }

    pub fn get_next(&self, item: &T) -> T {
        let index = self.data.iter().position(|x| *x == *item);
        match index {
            Some(i) => {
                if i == self.data.len() - 1 {
                    self.data[0].clone()
                } else {
                    self.data[i + 1].clone()
                }
            }
            None => self.data[0].clone(),
        }
    }
}

impl<T: PartialEq + Clone> Default for RecurrenceVec<T> {
    fn default() -> Self {
        RecurrenceVec { data: Vec::new() }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Frequency {
    Secondly,
    Minutely,
    Hourly,
    Daily,
    Weekly,
    Monthly,
    Yearly,
}

#[derive(Debug, Serialize, Deserialize, Clone, Copy, PartialEq, Eq)]
pub enum Weekday {
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
    Sunday,
}

impl Weekday {
    pub fn from_chrono(weekday: &chrono::Weekday) -> Weekday {
        match weekday {
            chrono::Weekday::Mon => Weekday::Monday,
            chrono::Weekday::Tue => Weekday::Tuesday,
            chrono::Weekday::Wed => Weekday::Wednesday,
            chrono::Weekday::Thu => Weekday::Thursday,
            chrono::Weekday::Fri => Weekday::Friday,
            chrono::Weekday::Sat => Weekday::Saturday,
            chrono::Weekday::Sun => Weekday::Sunday,
        }
    }

    pub fn get_days_diff(&self, other: &Weekday) -> i32 {
        let mut diff = *self as i32 - *other as i32;
        if diff < 0 {
            diff += 7;
        }
        diff
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RecurrenceDay {
    // 20th monday or first sunday
    pub recurence: u32,
    pub weekday: Weekday,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(transparent)]
pub struct Date {
    #[serde(with = "bson::serde_helpers::chrono_datetime_as_bson_datetime")]
    pub date: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Recurrence {
    pub frequency: Frequency,

    pub interval: u32,

    pub count: Option<u32>,

    pub until_date: Option<Date>,

    pub week_start: Option<Weekday>,

    pub excluded_dates: Vec<Date>,

    pub recurrences: Vec<RecurrenceDay>,
    pub weekdays: RecurrenceVec<Weekday>,
    pub set_pos: RecurrenceVec<i32>,

    pub hours: RecurrenceVec<u32>,
    pub minutes: RecurrenceVec<u32>,
    pub seconds: RecurrenceVec<u32>,
    pub year_days: RecurrenceVec<u32>,
    pub month_days: RecurrenceVec<u32>,
    pub months: RecurrenceVec<u32>,
}

impl Recurrence {
    pub fn calculate_included_dates(
        &self,
        start_date: DateTime<Utc>,
        end_date: DateTime<Utc>,
    ) -> Vec<DateTime<Utc>> {
        /* Returns all included dates in the recurrence, between start_date and end_date */
        /* If freq is SECONDLY, we advance every `interval` seconds, but:
                - Only in the months specified in `months`,
                - Only in the days specified in `month_days` and `year_days` and `weekdays`,
                - Only in the hours specified in `hours`,
                - Only in the minutes specified in `minutes`,
                - Only in the seconds specified in `seconds`,
        */
        let mut included_dates = Vec::new();

        let mut current_date = start_date;
        let ending_date = match &self.until_date {
            Some(date) => {
                if date.date > end_date {
                    end_date
                } else {
                    date.date
                }
            }
            None => end_date,
        };

        let count = match self.count {
            Some(count) => count,
            None => 1000,
        };

        // SECONDLY freq
        match self.frequency {
            Frequency::Secondly => {
                let months = self.months.set_default((1..=12).collect());
                let year_days = self.year_days.set_default((1..=366).collect());
                let month_days = self.month_days.set_default((1..=31).collect());
                let weekdays = self.weekdays.set_default(vec![
                    Weekday::Monday,
                    Weekday::Tuesday,
                    Weekday::Wednesday,
                    Weekday::Thursday,
                    Weekday::Friday,
                    Weekday::Saturday,
                    Weekday::Sunday,
                ]);
                let hours = self.hours.set_default((0..=23).collect());
                let minutes = self.minutes.set_default((0..=59).collect());
                let seconds = self.seconds.set_default((0..=59).collect());

                loop {
                    if count == 0 {
                        break;
                    }
                    if current_date > ending_date {
                        break;
                    }
                    if !months.contains(&current_date.month()) {
                        // Skip to next month
                        let next_month = months.get_next(&current_date.month());
                        if next_month > current_date.month() {
                            current_date = current_date
                                .with_month(next_month)
                                .unwrap()
                                .with_day(1)
                                .unwrap();
                        } else {
                            current_date = current_date
                                .with_year(current_date.year() + 1)
                                .unwrap()
                                .with_month(next_month)
                                .unwrap()
                                .with_day(1)
                                .unwrap();
                        }
                        continue;
                    }
                    if !year_days.contains(&current_date.ordinal0()) {
                        // Skip to next year day
                        let next_year_day = year_days.get_next(&current_date.ordinal0());
                        if next_year_day > current_date.ordinal0() {
                            current_date = current_date.with_day0(next_year_day).unwrap();
                        } else {
                            current_date = current_date
                                .with_year(current_date.year() + 1)
                                .unwrap()
                                .with_day0(next_year_day)
                                .unwrap();
                        }
                        continue;
                    }
                    if !month_days.contains(&current_date.day()) {
                        // Skip to next month day
                        let next_month_day = month_days.get_next(&current_date.day());
                        if next_month_day > current_date.day() {
                            current_date = current_date.with_day(next_month_day).unwrap();
                        } else {
                            current_date = current_date
                                .with_month(current_date.month() + 1)
                                .unwrap()
                                .with_day(next_month_day)
                                .unwrap();
                        }
                        continue;
                    }
                    if !weekdays.contains(&Weekday::from_chrono(&current_date.weekday())) {
                        // Skip to next weekday
                        let next_weekday =
                            weekdays.get_next(&Weekday::from_chrono(&current_date.weekday()));
                        let days_diff = next_weekday
                            .get_days_diff(&Weekday::from_chrono(&current_date.weekday()));
                        current_date += chrono::Duration::days(days_diff as i64);
                        continue;
                    }
                    if !hours.contains(&current_date.hour()) {
                        // Skip to next hour
                        let next_hour = hours.get_next(&current_date.hour());
                        if next_hour > current_date.hour() {
                            current_date = current_date.with_hour(next_hour).unwrap();
                        } else {
                            current_date = current_date
                                .with_day(current_date.day() + 1)
                                .unwrap()
                                .with_hour(next_hour)
                                .unwrap();
                        }
                        continue;
                    }
                    if !minutes.contains(&current_date.minute()) {
                        // Skip to next minute
                        let next_minute = minutes.get_next(&current_date.minute());
                        if next_minute > current_date.minute() {
                            current_date = current_date.with_minute(next_minute).unwrap();
                        } else {
                            current_date = current_date
                                .with_hour(current_date.hour() + 1)
                                .unwrap()
                                .with_minute(next_minute)
                                .unwrap();
                        }
                        continue;
                    }

                    if !seconds.contains(&current_date.second()) {
                        // Skip to next second
                        let next_second = seconds.get_next(&current_date.second());
                        if next_second > current_date.second() {
                            current_date = current_date.with_second(next_second).unwrap();
                        } else {
                            current_date = current_date
                                .with_minute(current_date.minute() + 1)
                                .unwrap()
                                .with_second(next_second)
                                .unwrap();
                        }
                        continue;
                    }

                    included_dates.push(current_date);

                    current_date += chrono::Duration::seconds(self.interval as i64);
                }
            }
            _ => (),
        }

        included_dates
    }
}

#[cfg(test)]
mod test {
    use chrono::TimeZone;

    use super::*;

    #[test]
    fn test_secondly() {
        let start_date = Utc.with_ymd_and_hms(2022, 1, 1, 0, 0, 0);
        let end_date = Utc.with_ymd_and_hms(2024, 1, 1, 0, 0, 0);

        let recurrence = Recurrence {
            frequency: Frequency::Secondly,
            interval: 5,
            until_date: Some(Date {
                date: end_date.earliest().unwrap(),
            }),
            week_start: None,
            weekdays: RecurrenceVec::default(),
            hours: RecurrenceVec { data: vec![5] },
            minutes: RecurrenceVec { data: vec![5] },
            seconds: RecurrenceVec {
                data: vec![5, 10, 12],
            },
            month_days: RecurrenceVec { data: vec![5] },
            months: RecurrenceVec { data: vec![5] },
            year_days: RecurrenceVec::default(),
            count: None,
            excluded_dates: Vec::default(),
            set_pos: RecurrenceVec::default(),
            recurrences: Vec::default(),
        };

        let included_dates = recurrence
            .calculate_included_dates(start_date.earliest().unwrap(), end_date.earliest().unwrap());

        assert_eq!(included_dates.len(), 4);
        assert_eq!(
            included_dates[0],
            Utc.with_ymd_and_hms(2022, 5, 5, 5, 5, 5)
                .earliest()
                .unwrap()
        );
        assert_eq!(
            included_dates[1],
            Utc.with_ymd_and_hms(2022, 5, 5, 5, 5, 10)
                .earliest()
                .unwrap()
        );
        assert_eq!(
            included_dates[2],
            Utc.with_ymd_and_hms(2023, 5, 5, 5, 5, 5)
                .earliest()
                .unwrap()
        );
        assert_eq!(
            included_dates[3],
            Utc.with_ymd_and_hms(2023, 5, 5, 5, 5, 10)
                .earliest()
                .unwrap()
        );
    }
}
